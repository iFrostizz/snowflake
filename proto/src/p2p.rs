// This file is @generated by prost-build.
/// Represents peer-to-peer messages.
/// Only one type can be non-null.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    /// NOTES
    /// Use "oneof" for each message type and set rest to null if not used.
    /// That is because when the compression is enabled, we don't want to include uncompressed fields.
    #[prost(
        oneof = "message::Message",
        tags = "2, 11, 12, 13, 35, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 34"
    )]
    pub message: ::core::option::Option<message::Message>,
}
/// Nested message and enum types in `Message`.
pub mod message {
    /// NOTES
    /// Use "oneof" for each message type and set rest to null if not used.
    /// That is because when the compression is enabled, we don't want to include uncompressed fields.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        /// zstd-compressed bytes of a "p2p.Message" whose "oneof" "message" field is
        /// NOT compressed_* BUT one of the message types (e.g. ping, pong, etc.).
        /// This field is only set if the message type supports compression.
        #[prost(bytes, tag = "2")]
        CompressedZstd(::prost::alloc::vec::Vec<u8>),
        /// Network messages:
        #[prost(message, tag = "11")]
        Ping(super::Ping),
        #[prost(message, tag = "12")]
        Pong(super::Pong),
        #[prost(message, tag = "13")]
        Handshake(super::Handshake),
        #[prost(message, tag = "35")]
        GetPeerList(super::GetPeerList),
        #[prost(message, tag = "14")]
        PeerList(super::PeerList),
        /// State-sync messages:
        #[prost(message, tag = "15")]
        GetStateSummaryFrontier(super::GetStateSummaryFrontier),
        #[prost(message, tag = "16")]
        StateSummaryFrontier(super::StateSummaryFrontier),
        #[prost(message, tag = "17")]
        GetAcceptedStateSummary(super::GetAcceptedStateSummary),
        #[prost(message, tag = "18")]
        AcceptedStateSummary(super::AcceptedStateSummary),
        /// Bootstrapping messages:
        #[prost(message, tag = "19")]
        GetAcceptedFrontier(super::GetAcceptedFrontier),
        #[prost(message, tag = "20")]
        AcceptedFrontier(super::AcceptedFrontier),
        #[prost(message, tag = "21")]
        GetAccepted(super::GetAccepted),
        #[prost(message, tag = "22")]
        Accepted(super::Accepted),
        #[prost(message, tag = "23")]
        GetAncestors(super::GetAncestors),
        #[prost(message, tag = "24")]
        Ancestors(super::Ancestors),
        /// Consensus messages:
        #[prost(message, tag = "25")]
        Get(super::Get),
        #[prost(message, tag = "26")]
        Put(super::Put),
        #[prost(message, tag = "27")]
        PushQuery(super::PushQuery),
        #[prost(message, tag = "28")]
        PullQuery(super::PullQuery),
        #[prost(message, tag = "29")]
        Chits(super::Chits),
        /// App messages:
        #[prost(message, tag = "30")]
        AppRequest(super::AppRequest),
        #[prost(message, tag = "31")]
        AppResponse(super::AppResponse),
        #[prost(message, tag = "32")]
        AppGossip(super::AppGossip),
        #[prost(message, tag = "34")]
        AppError(super::AppError),
    }
}
/// Ping reports a peer's perceived uptime percentage.
///
/// Peers should respond to Ping with a Pong.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ping {
    /// Uptime percentage on the primary network \[0, 100\]
    #[prost(uint32, tag = "1")]
    pub uptime: u32,
    /// Uptime percentage on subnets
    #[prost(message, repeated, tag = "2")]
    pub subnet_uptimes: ::prost::alloc::vec::Vec<SubnetUptime>,
}
/// SubnetUptime is a descriptor for a peer's perceived uptime on a subnet.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetUptime {
    /// Subnet the peer is validating
    #[prost(bytes = "vec", tag = "1")]
    pub subnet_id: ::prost::alloc::vec::Vec<u8>,
    /// Uptime percentage on the subnet \[0, 100\]
    #[prost(uint32, tag = "2")]
    pub uptime: u32,
}
/// Pong is sent in response to a Ping with the perceived uptime of the
/// peer.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pong {
    /// Deprecated: uptime is now sent in Ping
    /// Uptime percentage on the primary network \[0, 100\]
    #[prost(uint32, tag = "1")]
    pub uptime: u32,
    /// Deprecated: uptime is now sent in Ping
    /// Uptime percentage on subnets
    #[prost(message, repeated, tag = "2")]
    pub subnet_uptimes: ::prost::alloc::vec::Vec<SubnetUptime>,
}
/// Handshake is the first outbound message sent to a peer when a connection is
/// established to start the p2p handshake.
///
/// Peers must respond to a Handshake message with a PeerList message to allow the
/// peer to connect to other peers in the network.
///
/// Peers should drop connections to peers with incompatible versions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Handshake {
    /// Network the peer is running on (e.g local, testnet, mainnet)
    #[prost(uint32, tag = "1")]
    pub network_id: u32,
    /// Unix timestamp when this Handshake message was created
    #[prost(uint64, tag = "2")]
    pub my_time: u64,
    /// IP address of the peer
    #[prost(bytes = "vec", tag = "3")]
    pub ip_addr: ::prost::alloc::vec::Vec<u8>,
    /// IP port of the peer
    #[prost(uint32, tag = "4")]
    pub ip_port: u32,
    /// Timestamp of the IP
    #[prost(uint64, tag = "6")]
    pub ip_signing_time: u64,
    /// Signature of the peer IP port pair at a provided timestamp with the TLS
    /// key.
    #[prost(bytes = "vec", tag = "7")]
    pub ip_node_id_sig: ::prost::alloc::vec::Vec<u8>,
    /// Subnets the peer is tracking
    #[prost(bytes = "vec", repeated, tag = "8")]
    pub tracked_subnets: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "9")]
    pub client: ::core::option::Option<Client>,
    #[prost(uint32, repeated, tag = "10")]
    pub supported_acps: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "11")]
    pub objected_acps: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "12")]
    pub known_peers: ::core::option::Option<BloomFilter>,
    /// Signature of the peer IP port pair at a provided timestamp with the BLS
    /// key.
    #[prost(bytes = "vec", tag = "13")]
    pub ip_bls_sig: ::prost::alloc::vec::Vec<u8>,
}
/// Metadata about a peer's P2P client used to determine compatibility
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Client {
    /// Client name (e.g avalanchego)
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Client semantic version
    #[prost(uint32, tag = "2")]
    pub major: u32,
    #[prost(uint32, tag = "3")]
    pub minor: u32,
    #[prost(uint32, tag = "4")]
    pub patch: u32,
}
/// BloomFilter with a random salt to prevent consistent hash collisions
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BloomFilter {
    #[prost(bytes = "vec", tag = "1")]
    pub filter: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub salt: ::prost::alloc::vec::Vec<u8>,
}
/// ClaimedIpPort contains metadata needed to connect to a peer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimedIpPort {
    /// X509 certificate of the peer
    #[prost(bytes = "vec", tag = "1")]
    pub x509_certificate: ::prost::alloc::vec::Vec<u8>,
    /// IP address of the peer
    #[prost(bytes = "vec", tag = "2")]
    pub ip_addr: ::prost::alloc::vec::Vec<u8>,
    /// IP port of the peer
    #[prost(uint32, tag = "3")]
    pub ip_port: u32,
    /// Timestamp of the IP address + port pair
    #[prost(uint64, tag = "4")]
    pub timestamp: u64,
    /// Signature of the IP port pair at a provided timestamp
    #[prost(bytes = "vec", tag = "5")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// P-Chain transaction that added this peer to the validator set
    #[prost(bytes = "vec", tag = "6")]
    pub tx_id: ::prost::alloc::vec::Vec<u8>,
}
/// GetPeerList contains a bloom filter of the currently known validator IPs.
///
/// GetPeerList must not be responded to until finishing the handshake. After the
/// handshake is completed, GetPeerlist messages should be responded to with a
/// Peerlist message containing validators that are not present in the bloom
/// filter.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPeerList {
    #[prost(message, optional, tag = "1")]
    pub known_peers: ::core::option::Option<BloomFilter>,
}
/// PeerList contains network-level metadata for a set of validators.
///
/// PeerList must be sent in response to an inbound Handshake message from a
/// remote peer a peer wants to connect to. Once a PeerList is received after
/// a Handshake message, the p2p handshake is complete and the connection is
/// established.
///
/// PeerList should be sent in response to a GetPeerlist message if the handshake
/// has been completed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerList {
    #[prost(message, repeated, tag = "1")]
    pub claimed_ip_ports: ::prost::alloc::vec::Vec<ClaimedIpPort>,
}
/// GetStateSummaryFrontier requests a peer's most recently accepted state
/// summary
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateSummaryFrontier {
    /// Chain being requested from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Unique identifier for this request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Timeout (ns) for this request
    #[prost(uint64, tag = "3")]
    pub deadline: u64,
}
/// StateSummaryFrontier is sent in response to a GetStateSummaryFrontier request
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateSummaryFrontier {
    /// Chain being responded from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Request id of the original GetStateSummaryFrontier request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// The requested state summary
    #[prost(bytes = "vec", tag = "3")]
    pub summary: ::prost::alloc::vec::Vec<u8>,
}
/// GetAcceptedStateSummary requests a set of state summaries at a set of
/// block heights
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAcceptedStateSummary {
    /// Chain bein requested from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Unique identifier for this request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Timeout (ns) for this request
    #[prost(uint64, tag = "3")]
    pub deadline: u64,
    /// Heights being requested
    #[prost(uint64, repeated, tag = "4")]
    pub heights: ::prost::alloc::vec::Vec<u64>,
}
/// AcceptedStateSummary is sent in response to GetAcceptedStateSummary
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceptedStateSummary {
    /// Chain being responded from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Request id of the original GetAcceptedStateSummary request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// State summary ids
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub summary_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// GetAcceptedFrontier requests the accepted frontier from a peer.
///
/// Peers should respond to GetAcceptedFrontier with AcceptedFrontier.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAcceptedFrontier {
    /// Chain being requested from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Unique identifier for this request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Timeout (ns) for this request
    #[prost(uint64, tag = "3")]
    pub deadline: u64,
}
/// AcceptedFrontier contains the remote peer's last accepted frontier.
///
/// AcceptedFrontier is sent in response to GetAcceptedFrontier.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceptedFrontier {
    /// Chain being responded from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Request id of the original GetAcceptedFrontier request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// The id of the last accepted frontier
    #[prost(bytes = "vec", tag = "3")]
    pub container_id: ::prost::alloc::vec::Vec<u8>,
}
/// GetAccepted sends a request with the sender's accepted frontier to a remote
/// peer.
///
/// Peers should respond to GetAccepted with an Accepted message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccepted {
    /// Chain being requested from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Unique identifier for this message
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Timeout (ns) for this request
    #[prost(uint64, tag = "3")]
    pub deadline: u64,
    /// The sender's accepted frontier
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub container_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// Accepted is sent in response to GetAccepted. The sending peer responds with
/// a subset of container ids from the GetAccepted request that the sending peer
/// has accepted.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Accepted {
    /// Chain being responded from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Request id of the original GetAccepted request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Subset of container ids from the GetAccepted request that the sender has
    /// accepted
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub container_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// GetAncestors requests the ancestors for a given container.
///
/// The remote peer should respond with an Ancestors message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAncestors {
    /// Chain being requested from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Unique identifier for this request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Timeout (ns) for this request
    #[prost(uint64, tag = "3")]
    pub deadline: u64,
    /// Container for which ancestors are being requested
    #[prost(bytes = "vec", tag = "4")]
    pub container_id: ::prost::alloc::vec::Vec<u8>,
    /// Consensus type to handle this message
    #[prost(enumeration = "EngineType", tag = "5")]
    pub engine_type: i32,
}
/// Ancestors is sent in response to GetAncestors.
///
/// Ancestors contains a contiguous ancestry of containers for the requested
/// container in order of increasing block height.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ancestors {
    /// Chain being responded from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Request id of the original GetAncestors request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Ancestry for the requested container
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub containers: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// Get requests a container from a remote peer.
///
/// Remote peers should respond with a Put message if they have the container.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Get {
    /// Chain being requested from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Unique identifier for this request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Timeout (ns) for this request
    #[prost(uint64, tag = "3")]
    pub deadline: u64,
    /// Container being requested
    #[prost(bytes = "vec", tag = "4")]
    pub container_id: ::prost::alloc::vec::Vec<u8>,
}
/// Put is sent in response to Get with the requested block.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Put {
    /// Chain being responded from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Request id of the original Get request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Requested container
    #[prost(bytes = "vec", tag = "3")]
    pub container: ::prost::alloc::vec::Vec<u8>,
}
/// PushQuery requests the preferences of a remote peer given a container.
///
/// Remote peers should respond to a PushQuery with a Chits message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushQuery {
    /// Chain being requested from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Unique identifier for this request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Timeout (ns) for this request
    #[prost(uint64, tag = "3")]
    pub deadline: u64,
    /// Container being gossiped
    #[prost(bytes = "vec", tag = "4")]
    pub container: ::prost::alloc::vec::Vec<u8>,
    /// Requesting peer's last accepted height
    #[prost(uint64, tag = "6")]
    pub requested_height: u64,
}
/// PullQuery requests the preferences of a remote peer given a container id.
///
/// Remote peers should respond to a PullQuery with a Chits message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullQuery {
    /// Chain being requested from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Unique identifier for this request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Timeout (ns) for this request
    #[prost(uint64, tag = "3")]
    pub deadline: u64,
    /// Container id being gossiped
    #[prost(bytes = "vec", tag = "4")]
    pub container_id: ::prost::alloc::vec::Vec<u8>,
    /// Requesting peer's last accepted height
    #[prost(uint64, tag = "6")]
    pub requested_height: u64,
}
/// Chits contains the preferences of a peer in response to a PushQuery or
/// PullQuery message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chits {
    /// Chain being responded from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Request id of the original PushQuery/PullQuery request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Currently preferred block
    #[prost(bytes = "vec", tag = "3")]
    pub preferred_id: ::prost::alloc::vec::Vec<u8>,
    /// Last accepted block
    #[prost(bytes = "vec", tag = "4")]
    pub accepted_id: ::prost::alloc::vec::Vec<u8>,
    /// Currently preferred block at the requested height
    #[prost(bytes = "vec", tag = "5")]
    pub preferred_id_at_height: ::prost::alloc::vec::Vec<u8>,
}
/// AppRequest is a VM-defined request.
///
/// Remote peers must respond to AppRequest with a corresponding AppResponse or
/// AppError
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppRequest {
    /// Chain being requested from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Unique identifier for this request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Timeout (ns) for this request
    #[prost(uint64, tag = "3")]
    pub deadline: u64,
    /// Request body
    #[prost(bytes = "vec", tag = "4")]
    pub app_bytes: ::prost::alloc::vec::Vec<u8>,
}
/// AppResponse is a VM-defined response sent in response to AppRequest
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppResponse {
    /// Chain being responded from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Request id of the original AppRequest
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Response body
    #[prost(bytes = "vec", tag = "3")]
    pub app_bytes: ::prost::alloc::vec::Vec<u8>,
}
/// AppError is a VM-defined error sent in response to AppRequest
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppError {
    /// Chain the message is for
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Request id of the original AppRequest
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// VM defined error code. VMs may define error codes > 0.
    #[prost(sint32, tag = "3")]
    pub error_code: i32,
    /// VM defined error message
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
}
/// AppGossip is a VM-defined message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppGossip {
    /// Chain the message is for
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Message body
    #[prost(bytes = "vec", tag = "2")]
    pub app_bytes: ::prost::alloc::vec::Vec<u8>,
}
/// The consensus engine that should be used when handling a consensus request.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EngineType {
    Unspecified = 0,
    /// Only the X-Chain uses avalanche consensus
    Avalanche = 1,
    Snowman = 2,
}
impl EngineType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EngineType::Unspecified => "ENGINE_TYPE_UNSPECIFIED",
            EngineType::Avalanche => "ENGINE_TYPE_AVALANCHE",
            EngineType::Snowman => "ENGINE_TYPE_SNOWMAN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENGINE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ENGINE_TYPE_AVALANCHE" => Some(Self::Avalanche),
            "ENGINE_TYPE_SNOWMAN" => Some(Self::Snowman),
            _ => None,
        }
    }
}
