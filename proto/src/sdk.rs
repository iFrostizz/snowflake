// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullGossipRequest {
    #[prost(bytes = "vec", tag = "2")]
    pub salt: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub filter: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullGossipResponse {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub gossip: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushGossip {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub gossip: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LightRequest {
    #[prost(oneof = "light_request::Message", tags = "1, 11, 12")]
    pub message: ::core::option::Option<light_request::Message>,
}
/// Nested message and enum types in `LightRequest`.
pub mod light_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "1")]
        LightHandshake(super::LightHandshake),
        #[prost(message, tag = "11")]
        FindValue(super::FindValue),
        #[prost(message, tag = "12")]
        FindNode(super::FindNode),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DhtBuckets {
    #[prost(bytes = "vec", tag = "1")]
    pub block: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LightHandshake {
    #[prost(message, optional, tag = "1")]
    pub buckets: ::core::option::Option<DhtBuckets>,
}
/// FindValue is used to find content at a bucket by recursively getting closer
///
/// Works as defined in the Kademlia DHT paper: <https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindValue {
    #[prost(uint32, tag = "1")]
    pub dht_id: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub bucket: ::prost::alloc::vec::Vec<u8>,
}
/// FindNode is used to find nodes that are close from a bucket
///
/// Works as defined in the Kademlia DHT paper: <https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindNode {
    #[prost(bytes = "vec", tag = "1")]
    pub bucket: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LightResponse {
    #[prost(oneof = "light_response::Message", tags = "1, 2, 3")]
    pub message: ::core::option::Option<light_response::Message>,
}
/// Nested message and enum types in `LightResponse`.
pub mod light_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "1")]
        Ack(super::Ack),
        #[prost(message, tag = "2")]
        Nodes(super::super::p2p::PeerList),
        #[prost(message, tag = "3")]
        Value(super::Value),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ack {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
