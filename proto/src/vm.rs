// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeRequest {
    #[prost(uint32, tag = "1")]
    pub network_id: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub subnet_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub node_id: ::prost::alloc::vec::Vec<u8>,
    /// public_key is the BLS public key that would correspond with any signatures
    /// produced by the warp messaging signer
    #[prost(bytes = "vec", tag = "5")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub x_chain_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "7")]
    pub c_chain_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub avax_asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "9")]
    pub chain_data_dir: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "10")]
    pub genesis_bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "11")]
    pub upgrade_bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "12")]
    pub config_bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "13")]
    pub db_server_addr: ::prost::alloc::string::String,
    /// server_addr is the address of the gRPC server which serves
    /// the messenger, keystore, shared memory, blockchain alias,
    /// subnet alias, and appSender services
    #[prost(string, tag = "14")]
    pub server_addr: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub last_accepted_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub last_accepted_parent_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "3")]
    pub height: u64,
    #[prost(bytes = "vec", tag = "4")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetStateRequest {
    #[prost(enumeration = "State", tag = "1")]
    pub state: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetStateResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub last_accepted_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub last_accepted_parent_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "3")]
    pub height: u64,
    #[prost(bytes = "vec", tag = "4")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHandlersResponse {
    #[prost(message, repeated, tag = "1")]
    pub handlers: ::prost::alloc::vec::Vec<Handler>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Handler {
    #[prost(string, tag = "1")]
    pub prefix: ::prost::alloc::string::String,
    /// server_addr is the address of the gRPC server which serves the
    /// HTTP service
    #[prost(string, tag = "2")]
    pub server_addr: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BuildBlockRequest {
    #[prost(uint64, optional, tag = "1")]
    pub p_chain_height: ::core::option::Option<u64>,
}
/// Note: The status of a freshly built block is assumed to be Processing.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildBlockResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub parent_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub height: u64,
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "6")]
    pub verify_with_context: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseBlockRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseBlockResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub parent_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "Status", tag = "3")]
    pub status: i32,
    #[prost(uint64, tag = "4")]
    pub height: u64,
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "6")]
    pub verify_with_context: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub parent_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "Status", tag = "3")]
    pub status: i32,
    #[prost(uint64, tag = "4")]
    pub height: u64,
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// used to propagate database.ErrNotFound through RPC
    #[prost(enumeration = "Error", tag = "6")]
    pub err: i32,
    #[prost(bool, tag = "7")]
    pub verify_with_context: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetPreferenceRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockVerifyRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
    /// If set, the VM server casts the block to a \[block.WithVerifyContext\] and
    /// calls \[VerifyWithContext\] instead of \[Verify\].
    #[prost(uint64, optional, tag = "2")]
    pub p_chain_height: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlockVerifyResponse {
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockAcceptRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockRejectRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub details: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionResponse {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppRequestMsg {
    /// The node that sent us this request
    #[prost(bytes = "vec", tag = "1")]
    pub node_id: ::prost::alloc::vec::Vec<u8>,
    /// The ID of this request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// deadline for this request
    #[prost(message, optional, tag = "3")]
    pub deadline: ::core::option::Option<::prost_types::Timestamp>,
    /// The request body
    #[prost(bytes = "vec", tag = "4")]
    pub request: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppRequestFailedMsg {
    /// The node that we failed to get a response from
    #[prost(bytes = "vec", tag = "1")]
    pub node_id: ::prost::alloc::vec::Vec<u8>,
    /// The ID of the request we sent and didn't get a response to
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Application-defined error code
    #[prost(sint32, tag = "3")]
    pub error_code: i32,
    /// Application-defined error message
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppResponseMsg {
    /// The node that we got a response from
    #[prost(bytes = "vec", tag = "1")]
    pub node_id: ::prost::alloc::vec::Vec<u8>,
    /// Request ID of request that this is in response to
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// The response body
    #[prost(bytes = "vec", tag = "3")]
    pub response: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppGossipMsg {
    /// The node that sent us a gossip message
    #[prost(bytes = "vec", tag = "1")]
    pub node_id: ::prost::alloc::vec::Vec<u8>,
    /// The message body
    #[prost(bytes = "vec", tag = "2")]
    pub msg: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrossChainAppRequestMsg {
    /// The chain that sent us this request
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// The ID of this request
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// deadline for this request
    #[prost(message, optional, tag = "3")]
    pub deadline: ::core::option::Option<::prost_types::Timestamp>,
    /// The request body
    #[prost(bytes = "vec", tag = "4")]
    pub request: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrossChainAppRequestFailedMsg {
    /// The chain that we failed to get a response from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// The ID of the request we sent and didn't get a response to
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// Application-defined error code
    #[prost(sint32, tag = "3")]
    pub error_code: i32,
    /// Application-defined error message
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrossChainAppResponseMsg {
    /// The chain that we got a response from
    #[prost(bytes = "vec", tag = "1")]
    pub chain_id: ::prost::alloc::vec::Vec<u8>,
    /// Request ID of request that this is in response to
    #[prost(uint32, tag = "2")]
    pub request_id: u32,
    /// The response body
    #[prost(bytes = "vec", tag = "3")]
    pub response: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectedRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub node_id: ::prost::alloc::vec::Vec<u8>,
    /// Client name (e.g avalanchego)
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Client semantic version
    #[prost(uint32, tag = "3")]
    pub major: u32,
    #[prost(uint32, tag = "4")]
    pub minor: u32,
    #[prost(uint32, tag = "5")]
    pub patch: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisconnectedRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub node_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAncestorsRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub blk_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(int32, tag = "2")]
    pub max_blocks_num: i32,
    #[prost(int32, tag = "3")]
    pub max_blocks_size: i32,
    #[prost(int64, tag = "4")]
    pub max_blocks_retrival_time: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAncestorsResponse {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub blks_bytes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchedParseBlockRequest {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub request: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchedParseBlockResponse {
    #[prost(message, repeated, tag = "1")]
    pub response: ::prost::alloc::vec::Vec<ParseBlockResponse>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBlockIdAtHeightRequest {
    #[prost(uint64, tag = "1")]
    pub height: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockIdAtHeightResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub blk_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "Error", tag = "2")]
    pub err: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StateSyncEnabledResponse {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    #[prost(enumeration = "Error", tag = "2")]
    pub err: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOngoingSyncStateSummaryResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub height: u64,
    #[prost(bytes = "vec", tag = "3")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "Error", tag = "4")]
    pub err: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLastStateSummaryResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub height: u64,
    #[prost(bytes = "vec", tag = "3")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "Error", tag = "4")]
    pub err: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseStateSummaryRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseStateSummaryResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub height: u64,
    #[prost(enumeration = "Error", tag = "3")]
    pub err: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetStateSummaryRequest {
    #[prost(uint64, tag = "1")]
    pub height: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateSummaryResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "Error", tag = "3")]
    pub err: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateSummaryAcceptRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub bytes: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StateSummaryAcceptResponse {
    #[prost(enumeration = "state_summary_accept_response::Mode", tag = "1")]
    pub mode: i32,
    #[prost(enumeration = "Error", tag = "2")]
    pub err: i32,
}
/// Nested message and enum types in `StateSummaryAcceptResponse`.
pub mod state_summary_accept_response {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        Skipped = 1,
        Static = 2,
        Dynamic = 3,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::Skipped => "MODE_SKIPPED",
                Self::Static => "MODE_STATIC",
                Self::Dynamic => "MODE_DYNAMIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MODE_SKIPPED" => Some(Self::Skipped),
                "MODE_STATIC" => Some(Self::Static),
                "MODE_DYNAMIC" => Some(Self::Dynamic),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    Unspecified = 0,
    StateSyncing = 1,
    Bootstrapping = 2,
    NormalOp = 3,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATE_UNSPECIFIED",
            Self::StateSyncing => "STATE_STATE_SYNCING",
            Self::Bootstrapping => "STATE_BOOTSTRAPPING",
            Self::NormalOp => "STATE_NORMAL_OP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "STATE_STATE_SYNCING" => Some(Self::StateSyncing),
            "STATE_BOOTSTRAPPING" => Some(Self::Bootstrapping),
            "STATE_NORMAL_OP" => Some(Self::NormalOp),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
    Unspecified = 0,
    Processing = 1,
    Rejected = 2,
    Accepted = 3,
}
impl Status {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATUS_UNSPECIFIED",
            Self::Processing => "STATUS_PROCESSING",
            Self::Rejected => "STATUS_REJECTED",
            Self::Accepted => "STATUS_ACCEPTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "STATUS_PROCESSING" => Some(Self::Processing),
            "STATUS_REJECTED" => Some(Self::Rejected),
            "STATUS_ACCEPTED" => Some(Self::Accepted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Error {
    /// ERROR_UNSPECIFIED is used to indicate that no error occurred.
    Unspecified = 0,
    Closed = 1,
    NotFound = 2,
    StateSyncNotImplemented = 3,
}
impl Error {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ERROR_UNSPECIFIED",
            Self::Closed => "ERROR_CLOSED",
            Self::NotFound => "ERROR_NOT_FOUND",
            Self::StateSyncNotImplemented => "ERROR_STATE_SYNC_NOT_IMPLEMENTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR_CLOSED" => Some(Self::Closed),
            "ERROR_NOT_FOUND" => Some(Self::NotFound),
            "ERROR_STATE_SYNC_NOT_IMPLEMENTED" => Some(Self::StateSyncNotImplemented),
            _ => None,
        }
    }
}
